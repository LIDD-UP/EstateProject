    1：17.48:
    开始爬取，使用的是
    setting 中的配置情况：
        CONCURRENT_REQUESTS = 100
    # 降低log级别：降低到INFO级别就不能获取重定向的一些信息了
    # LOG_LEVEL = 'INFO'
    # 对于不需要登陆的网站禁用cookies
    COOKIES_ENABLED = False
    # 禁止重试:对于失败的http请求取消重试；但是这个还需要考虑
    RETRY_ENABLED = False

    # 如果您对一个非常慢的连接进行爬取(一般对通用爬虫来说并不重要)， 减小下载超时能让卡住的连接能被快速的放弃并解放处理其他站点的能力。
    DOWNLOAD_TIMEOUT = 15 # 其中15是设置的下载超时时间

    # 禁止重定向
    REDIRECT_ENABLED = False
    # 设置代理ip池，可以使用downloadermiddleware
    # 配置请求头


    # 自动限速设置：
    AUTOTHROTTLE_ENABLED = True
    DOWNLOAD_DELAY = 1
    2019-01-18 17:57:04 [scrapy.extensions.logstats] INFO: Crawled 75 pages (at 0 pages/min), scraped 36 items (at 0 items/min)

2：18.27
    100 并发去掉：（使用1）可能是fiddler的原因；
    2019-01-18 18:30:40 [scrapy.extensions.logstats] INFO: Crawled 67 pages (at 12 pages/min), scraped 32 items (at 5 items/min)
3：18.27：关掉fiddler代理


4:直接重构代码，详情页不用接口爬取；
    1:使用哈尔滨的网络，参数调到最低，没过多久就封ip了
    2：使用遨游vpn，使用美国的线路，相同参数效果还算稳定；
        能够跑完，但是数据量不够，不知道那里出问题了：
            找到原因了：xpath语法的原因；
        12：13开发抓的，使用最低配置：使用遨游，抓取时间：

总结：使用哈尔滨的ip不管是抓接口还是抓dom，美国都多就封了；（使用的还是最低的配置）抓了30多个item就封了

使用遨游vpn：
    各项参数调到最低也是直接封ip（抓了284）个
    2019-01-21 12:41:26 [scrapy.extensions.logstats] INFO: Crawled 316 pages (at 33 pages/min), scraped 284 items (at 12 items/min)
    反正抓取的时间不长；

    加上referer：一样的

    我怀疑是如果禁用了cookies之后对于一个ip会有用户个数限制，如果用户量过多，就会直接封ip

    # 加上一些别的浏览器标识，禁用cookie，自动限速看一下情况：
     Crawled 83 pages (at 39 pages/min), scraped 29 items (at 0 items/min)
     果然是针对用cookie级别的封锁；
     不同的ip有用户量的限制；


新的办法，
    1：使用无头浏览器，大量获取网站的cookies，然后封完一个cookies之后再使用另外一个cookies，这样把封锁限制到用户级别，
     <div class="alert alert-sm alert-warning alert-corner alert-dismissible no-show" role="alert" id="notification-cookies">
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span aria-hidden="true">&times;</span>
            </button>
            <span>It looks like Cookies are disabled in your browser. For the best experience, please enable cookies when using our site.</span>
        </div>

看了一遍最新的文章发现scrapy有自动管理cookie的功能
但是使用cookie的时候也是同样发送几十个请求之后封了ip；（哈尔冰的网络）但是agent是动态的，
注释掉动态的agent；情况：
2019-01-22 16:04:07 [scrapy.extensions.logstats] INFO: Crawled 82 pages (at 37 pages/min), scraped 31 items (at 0 items/min)
情况一样；

目前能做的可能性就是用美国的网络：在启用cookie的情况下（在要被封之前就清除cookie，重新获取cookie）不然一被封就是ip被封，不是封一个cookie
这种情况下就要获取大量的cookie；（但是同一个ip下新的cookie过多也会被封，）
所以这个网站很恐怖，
参数调到最低的情况下依旧被封；

# 接下来尝试怎样大量获取该网站的cookie以及一个ip地址下最多存在多少cookie:
使用requests库;


realtor 网站cookie的生成机制:浏览器只要一刷新,产生的cookie就和上次的cookie不太一样;但是还是有一本分是相同的;后面有一段开始就不同的,可能是前端产生的;里面还有一段搜索条件;


测试在同一个ip下:同一个cookies不限速度能请求多少次(使用python requests 库)
    接下来发生的情况:
        1:在浏览器中能够访问网站,没有被重定向到ipblock页面
        2:去掉cookie,再访问,不行
        3:去掉cookie,加上user-agent 不行
        4:再加上浏览器的一些标识之后,可以,
            然后利用这些浏览器标识和cookie,使用chrome浏览器作为user-agent,请求200多次后被封了,
            被封的方式是封的浏览器,cookie不知道有没有被封;(也就是说,优先封锁的浏览器,这很奇怪;)
                测试cookies有没有被封;
                测试发现新的user-agent + 以前被封的cookies一样能请求通过,所以,他没有针对cookie进行封锁,也就是说可以是针对user-agent的封锁
                (因为发现,用新的url去请求也是一样的)

                但是这还是不能说明问题,应为用的是requests库,反复请求同一个网站导致的封锁;


接下来在继续测试下面的假设:---------->>如果不带cookies过去,单纯的只      是夹带useragent过去;
    结果:



系统一下测试过程:
    1:分析网络请求的要素
        1:浏览器请求普遍的header
        2:浏览器请求重要的header元素
            1:user-agent
            2:cookie

#这些测试都是基于台湾125.227.36.106(这个ip的范围:125.227.30.0 - 125.227.61.255)(考虑到这个网站对不同地区的ip的流量限制不同)
存在问题:考虑到之前用scrapy爬取网站禁用cookie之后直接封ip,还有结合前面的简单测试发现优先封的是user-agent所以
    优先测试带cookie的情况:(接下来默认带cookie)(测试分为两组,一组是request反复请求同一个url,以及scrapy的规律爬取)
    1:request组(带cookie)
        1:使用requests啥都不加
            带cookie过去,直接用python-request作为user-agent,刚开始能够访问,没几下就不能访问了(没有直接封ip)
                用浏览器还能访问(使用的google的解析出的cookie,chrome和firefox都能访问);
            1:过一会再请求:
                重定向到userblock页面,同上面;
            2:更换cookie
                同

        2:使用requests+普通的浏览器请求header #
            也是出现问题;(直接重定向到userblock

        3:使用request+user-agent
            1:没有加在一定时间停止后再请求:
                只能请求130多次
                1:更换浏览器没有更换cookie,请求2次就被封了;可能是昨天测试的时候,这个user-agent被封过
                两个浏览器的问题:
                # 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',
                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:25.0) Gecko/20100101 Firefox/25.0',
                    这里可以做个推测对于不同平台或者不同版本的浏览器的user-agent也有不同的区别.,封禁的量级不同;
                2:在换一个更新的user-agent:依然能请求很多次;
                    请求次数是:
                3:添加一些时间停顿

    2:scrapy 组(带cookie)(要想使用自己的cookie要禁用cookieenable)
        1:裸奔
        2:加一些普通的浏览器标识
        3:user-agent
        4:随机变换user-agent
        5:user-agent 被封了之后在变;同时将被302的url重新yieldscapy下载器中
    3:request组(不带cookie) (不带cookie有很大的可能直接封ip)
        1:使用requests啥都不加
        2:使用requests+普通的浏览器请求header
        3:使用request+
    4:scrapy 组(带cookie)(要想使用自己的cookie要禁用cookieenable)
        1:裸奔
        2:加一些普通的浏览器标识
        3:user-agent
        4:随机变换user-agent
        5:user-agent 被封了之后在变;同时将被302的url重新yieldscapy下载器中







