    1：17.48:
    开始爬取，使用的是
    setting 中的配置情况：
        CONCURRENT_REQUESTS = 100
    # 降低log级别：降低到INFO级别就不能获取重定向的一些信息了
    # LOG_LEVEL = 'INFO'
    # 对于不需要登陆的网站禁用cookies
    COOKIES_ENABLED = False
    # 禁止重试:对于失败的http请求取消重试；但是这个还需要考虑
    RETRY_ENABLED = False

    # 如果您对一个非常慢的连接进行爬取(一般对通用爬虫来说并不重要)， 减小下载超时能让卡住的连接能被快速的放弃并解放处理其他站点的能力。
    DOWNLOAD_TIMEOUT = 15 # 其中15是设置的下载超时时间

    # 禁止重定向
    REDIRECT_ENABLED = False
    # 设置代理ip池，可以使用downloadermiddleware
    # 配置请求头


    # 自动限速设置：
    AUTOTHROTTLE_ENABLED = True
    DOWNLOAD_DELAY = 1
    2019-01-18 17:57:04 [scrapy.extensions.logstats] INFO: Crawled 75 pages (at 0 pages/min), scraped 36 items (at 0 items/min)

2：18.27
    100 并发去掉：（使用1）可能是fiddler的原因；
    2019-01-18 18:30:40 [scrapy.extensions.logstats] INFO: Crawled 67 pages (at 12 pages/min), scraped 32 items (at 5 items/min)
3：18.27：关掉fiddler代理


4:直接重构代码，详情页不用接口爬取；
    1:使用哈尔滨的网络，参数调到最低，没过多久就封ip了
    2：使用遨游vpn，使用美国的线路，相同参数效果还算稳定；
        能够跑完，但是数据量不够，不知道那里出问题了：
            找到原因了：xpath语法的原因；
        12：13开发抓的，使用最低配置：使用遨游，抓取时间：

总结：使用哈尔滨的ip不管是抓接口还是抓dom，美国都多就封了；（使用的还是最低的配置）抓了30多个item就封了

使用遨游vpn：
    各项参数调到最低也是直接封ip（抓了284）个
    2019-01-21 12:41:26 [scrapy.extensions.logstats] INFO: Crawled 316 pages (at 33 pages/min), scraped 284 items (at 12 items/min)
    反正抓取的时间不长；

    加上referer：一样的

    我怀疑是如果禁用了cookies之后对于一个ip会有用户个数限制，如果用户量过多，就会直接封ip

    # 加上一些别的浏览器标识，禁用cookie，自动限速看一下情况：
     Crawled 83 pages (at 39 pages/min), scraped 29 items (at 0 items/min)
     果然是针对用cookie级别的封锁；
     不同的ip有用户量的限制；


新的办法，
    1：使用无头浏览器，大量获取网站的cookies，然后封完一个cookies之后再使用另外一个cookies，这样把封锁限制到用户级别，
     <div class="alert alert-sm alert-warning alert-corner alert-dismissible no-show" role="alert" id="notification-cookies">
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span aria-hidden="true">&times;</span>
            </button>
            <span>It looks like Cookies are disabled in your browser. For the best experience, please enable cookies when using our site.</span>
        </div>

看了一遍最新的文章发现scrapy有自动管理cookie的功能
但是使用cookie的时候也是同样发送几十个请求之后封了ip；（哈尔冰的网络）但是agent是动态的，
注释掉动态的agent；情况：
2019-01-22 16:04:07 [scrapy.extensions.logstats] INFO: Crawled 82 pages (at 37 pages/min), scraped 31 items (at 0 items/min)
情况一样；

目前能做的可能性就是用美国的网络：在启用cookie的情况下（在要被封之前就清除cookie，重新获取cookie）不然一被封就是ip被封，不是封一个cookie
这种情况下就要获取大量的cookie；（但是同一个ip下新的cookie过多也会被封，）
所以这个网站很恐怖，
参数调到最低的情况下依旧被封；

# 接下来尝试怎样大量获取该网站的cookie以及一个ip地址下最多存在多少cookie:
使用requests库;


realtor 网站cookie的生成机制:浏览器只要一刷新,产生的cookie就和上次的cookie不太一样;但是还是有一本分是相同的;后面有一段开始就不同的,可能是前端产生的;里面还有一段搜索条件;


测试在同一个ip下:同一个cookies不限速度能请求多少次(使用python requests 库)
    接下来发生的情况:
        1:在浏览器中能够访问网站,没有被重定向到ipblock页面
        2:去掉cookie,再访问,不行
        3:去掉cookie,加上user-agent 不行
        4:再加上浏览器的一些标识之后,可以,
            然后利用这些浏览器标识和cookie,使用chrome浏览器作为user-agent,请求200多次后被封了,
            被封的方式是封的浏览器,cookie不知道有没有被封;(也就是说,优先封锁的浏览器,这很奇怪;)
                测试cookies有没有被封;
                测试发现新的user-agent + 以前被封的cookies一样能请求通过,所以,他没有针对cookie进行封锁,也就是说可以是针对user-agent的封锁
                (因为发现,用新的url去请求也是一样的)

                但是这还是不能说明问题,应为用的是requests库,反复请求同一个网站导致的封锁;


接下来在继续测试下面的假设:---------->>如果不带cookies过去,单纯的只      是夹带useragent过去;
    结果:



系统一下测试过程:
    1:分析网络请求的要素
        1:浏览器请求普遍的header
        2:浏览器请求重要的header元素
            1:user-agent
            2:cookie

#这些测试都是基于台湾125.227.36.106(这个ip的范围:125.227.30.0 - 125.227.61.255)(考虑到这个网站对不同地区的ip的流量限制不同)
    该ip ping www.realtor.com ping出的ip为(13.35.165.23)在美国;
存在问题:考虑到之前用scrapy爬取网站禁用cookie之后直接封ip,还有结合前面的简单测试发现优先封的是user-agent所以
    优先测试带cookie的情况:(接下来默认带cookie)(测试分为两组,一组是request反复请求同一个url,以及scrapy的规律爬取)
    1:request组(带cookie)
        1:使用requests啥都不加
            带cookie过去,直接用python-request作为user-agent,刚开始能够访问,没几下就不能访问了(没有直接封ip)
                用浏览器还能访问(使用的google的解析出的cookie,chrome和firefox都能访问);
            1:过一会再请求:
                重定向到userblock页面,同上面;
            2:更换cookie
                同

        2:使用requests+普通的浏览器请求header #
            也是出现问题;(直接重定向到userblock

        3:使用request+user-agent
            1:没有加在一定时间停止后再请求:
                只能请求130多次
                1:更换浏览器没有更换cookie,请求2次就被封了;可能是昨天测试的时候,这个user-agent被封过
                两个浏览器的问题:
                # 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',
                'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:25.0) Gecko/20100101 Firefox/25.0',
                    这里可以做个推测对于不同平台或者不同版本的浏览器的user-agent也有不同的区别.,封禁的量级不同;
                2:在换一个更新的user-agent:依然能请求很多次;
                    9.20开始:到10:00.总共2000多次请求,也就是说每分钟请求在60次左右,
                    请求次数是:60/min,这种速度情况下能够稳定抓取,但是在scrapy的情况下不一定;
                3:添加一些时间停顿
                    暂时不测,等一下再scrapy进行用request的目的在于分析网站是否对referer有限制;

            总结一:通过用requests对同一个url反复请求发现,加上cookie 和user-agent在速度60次请求/min的情况下是能够稳定抓取的;
                但是这个结论还不一定,影响因素还有可能是user-agent的版本;或者是平台;
                在之前的:    # 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36',
                请求130多次也是被禁了,但是禁止的是user-agent
                    优化方向:加快爬取速度,再user-agent被封的情况下更换user-agent;
                    还有个是随时一直更换user-agent,但是之前用scrapy,直接就封了ip,(禁用cookie和启用cookie的情况下都是,没有用浏览器复制出来的cookie)
                        所以这里先做一个假设就是:这个网站有两个级别的封锁,首先是user-agent的封锁,其次是ip的封锁;(有点是错杀一千,不放过一个的感觉)

    2:scrapy 组(带cookie)(要想使用自己的cookie要禁用cookieenable)(使用接口)
        1:裸奔

        2:加一些普通的浏览器标识
        3:user-agent
        4:随机变换user-agent
        5:user-agent 被封了之后在变;同时将被302的url重新yieldscapy下载器中
    3:request组(不带cookie) (不带cookie有很大的可能直接封ip)
        1:使用requests啥都不加
        2:使用requests+普通的浏览器请求header
        3:使用request+
    4:scrapy 组(带cookie)(要想使用自己的cookie要禁用cookieenable)(使用接口)
        1:裸奔
        2:加一些普通的浏览器标识
        3:user-agent
        4:随机变换user-agent
        5:user-agent 被封了之后在变;同时将被302的url重新yieldscapy下载器中


    IIIV:还有两组是scrapy关于不使用接口的情况;
    1:带cookie

    2:不带cookie



    总结:以前把速度降到最慢还是被封ip:起始并不是封ip,只是scrapy设置错误,用的是本地电脑最新版的,所以被封了,
    但是也有可能是哈尔滨ip的问题;

   测试动态user-agent+禁用cookie的情况:
            1:在爬取一个州下的一个县的时候:(数据量只有465个的情况)能够完全获取
            2:对全局进行抓取(也就是把所有的条件放入起始请求的情况下,没过多久直接被封ip了
            这里做出如下假设:
                1:夹带cookie进行请求:(全局请求)
                    结果:在请求了160多次之后被封了ip:这里可以得出结论(结合之前user-agent固定之后被封的情况)cookie对这个网站识别没有作用,它不会封cookie,但是会
                        封user-agent,如果你的user-agent是动态变化的,那它找不到封锁的东西就直接封锁ip了;但是这个结论要测试是否跟
                            同一个ip请求的州的个数过多导致的);

                2:再测试一个州下的一个县:(基于假设:可能从一个ip请求地区差异太大导致ip被封)
                只抓一个州下的一个县的数据的时候,不太容易被封,如果进行全局的抓取,如果一个ip同时请求过很多不同州下的数据,那就可能被封
                再进行测试新的一个州中县的数据,就拿纽约州下的纽约县进行测试;



                3:关于一个ip请求流量的限制(由于我之前对https://www.realtor.com/realestateandhomes-search/Autauga-County_AL)这个url抓取过几次;

                2019-01-24 15:03:02 [scrapy.extensions.logstats] INFO: Crawled 627 pages (at 50 pages/min), scraped 592 items (at 47 items/min)
                1:可以得出以下的结论,在上面的速度下,抓取一个州下面的某一个县的数据是没有问题的;(使用动态user-agent,禁用cookie的情况下)
                2:但是如果进行全局抓取,请求了160多个请求之后就被封了ip(动态user-agent的情况)
                3:还有一种方式是进行全局抓取,不随机变换user-agent,当一个user-agent被封了之后再再更换user-agent,这样就可以将封锁限制在user-agent
                    的级别,而保护ip,并且这样还能进行提速(但是也有一定风险被封ip)
                4:还有一种情况是这个网站对json数据接口没有做限制,而对page页的url,和州县页那种实际页面进行了限制
                    1:关于这种限制的假设有可能是关于由于我们没有执行某个js验证导致的,(网页可以根据我们有没有执行某一段js代码来判断是不是人类)
                    2:还是关于对同一个ip请求多个州下面的地区导致的,(更具搜索地区来进行限制)但是可能性没有上面的大);
                    可以进行假设验证:
                        再写一个程序:
                            1:直接循环爬取搜索条件:看一下请求是不是在160多次就封ip(验证是不是有地区的限制)
                            2:再同一个州下,直接迅速请求页面(验证是不是对请求个数有限制)(或者是js的限制)

                    realtor网站的停止策略:
                    再setting里设置一个暂停信号:stop_signal;写一个middleware,当遇到302的时候就+1;加到10之后就调用停止爬虫;
                    抓josn的抓取策略:需要外部一个脚本:
                        1:这种情况下就可以利用分布式的方式进行(但是不能是同一台电脑)
                        2:利用外部脚本(再写一个main函数调用)

                还有一项没有测试,就是没带cookie,加user-agent的情况如何:
                        在慢速的情况下,还算正常;台湾的vpn,
                        测试快速的情况下(哈尔滨ip)
                            没过多久(就几十个请求,直接被封)但是没有直接封ip,封的是user-agent,
                            换上新的user-agent,能够访问,但是请求几次又被封,
                            所以哈尔滨的ip不能用;
                            换成台湾vpn2,原来的就又可以了,
                                当不加cookie的情况下:单一的一个user-agent是能够在慢速,就是挂vpn的情况下跑的,但是,加上
                                    cookie 之后,又是请求

            这个网站是ip加user-agent的封锁;
            如果有user-agent 就封user-agent,没有就直接封ip,cookie还需测试:
                    换上台湾的ip能够稳定运行,但是由于网速原因,跑的有点慢,

            流量到达200kb的时候就会被封,台湾的ip
            但是用没过的ip开启3个,网速也达到了200kb,但是没有被封;


            使用美国3的vpn,开启3个进程的情况下
                1:抓取速度和下载速度没有提升,一直是在20kb以下,
                    1:对于多进程的理解不够深入,程序写错了,没有充分利用带宽;
                    2:vpn的速度问题
                2: 这个user-agent封禁有点厉害:User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:29.0) Gecko/20120101 Firefox/29.0
                3:关于程序中依然存在的问题:
                    1:其中一个遇到302将请求返回的middleware有问题,返回的时候它请求本身的user-agent没有变化,
                    2:第二个关于处理302错误的也一样有问题,还需要调试;
                        1:对于多个进程的爬虫,共用一个middleware(302),程序共用一个user-agent列表,当遇到问题的时候可能会出现一样的情况)
                            这个时候就相当于设置con-request为多个的情况了,所以需要修改程序使用不同的user-agent



                    在爬取美国所有的数据的时候的问题i:
                        1:使用动态user-agent+禁用cookie的情况:(美国的ip)
                            出现160多次请求之后就不能再请求
                            或者是次数更多但是直接封的ip
                        2:当使用不变的user-agent(韩国的ip)user-agent为:User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322)
                            请求了200多次就被被禁用了,

                        综合1,2点,以及目前正在抓取的数据来讲:
                            1:如果频繁的访问包含html的页面,会被封ip或者是user-agent,(请求频次的反爬)
                            2:html的动态页面反爬(js文件加载的问题),如果发现请求很多次都没加载js文件,直接人为是爬虫
                            3:侧面反映出json数据接口的反爬比html的反爬要更加松一些;
                            4:也就是说,在后面的爬虫中要尽量避免在一分钟内过多的请求太多次数的html
                            5:加上cookie之后,同样的存在这个问题;所以,这个网站cookie基本没用
                                并且把爬虫的参数调到最低依旧会出现相应的问题;

                            6:去掉referer然后加上cookie的情况要更好一些:
                            custom_settins:
                                custom_settings = {
                                   "ITEM_PIPELINES": {
                                        'AmericanRealEstate.pipelines.StatisticRealtorHouseCountPipeline': 301,
                                        # 'AmericanRealEstate.pipelines.RealtorDetailDomPipeline': 302,
                                        # 'AmericanRealEstate.pipelines.RealtorHouseInfoTestPipeline': 302,
                                        # 'scrapy_redis.pipelines.RedisPipeline': 300

                                    },
                                    "DOWNLOADER_MIDDLEWARES":{
                                    # 'AmericanRealEstate.middlewares.AmericanrealestateDownloaderMiddleware': 543,
                                    #  'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,
                                     # 'AmericanRealEstate.middlewares.RandomUserAgentMiddleware': 543,
                                     #    'AmericanRealEstate.middlewares.Process302Middleware' :544,
                                     #    'AmericanRealEstate.middlewares.AlertUserAgentWhenEncounter302Middleware': 545,
                                },
                                    "DEFAULT_REQUEST_HEADERS": {
                                            'authority': 'www.realtor.com',
                                            'method': 'GET',
                                            # 'path':'/sitemap/Alabama-real-estate/',
                                            'scheme': 'https',
                                            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,',
                                            'accept-encoding': 'gzip, deflate, br',
                                            'accept-language': 'zh-CN,zh;q=0.9,ja;q=0.8',
                                            'cache-control': 'no-cache',
                                            'upgrade - insecure - requests': '1',
                                            'cookie': '_ss=1366x768; threshold_value=89; clstr=v; clstr_tcv=54; split_tcv=60; __vst=fd0f0f5d-d57b-48c8-84f7-ee9332f86618; __gads=ID=c9c6bc68343b1c38:T=1547191429:S=ALNI_MbEoOR211jKBxjj3c6AxORc9rNejw; _gcl_au=1.1.462908694.1547191500; ajs_user_id=null; ajs_group_id=null; _ga=GA1.2.1809646443.1547191147; __qca=P0-1856484682-1547191544959; ajs_anonymous_id=%22db0f4b00-cb6b-4f3b-b074-13c91af6e735%22; _ncg_g_id_=4911c6ac-7925-4d04-8b99-bce40fcc0b74; AMCV_8853394255142B6A0A4C98A4%40AdobeOrg=-179204249%7CMCIDTS%7C17919%7CMCMID%7C78470061863700216203027265384897932330%7CMCAAMLH-1548725294%7C11%7CMCAAMB-1548725295%7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y%7CMCCIDH%7C-549291961%7CMCOPTOUT-1548127694s%7CNONE%7CMCAID%7CNONE; _gid=GA1.2.1644294370.1548120496; _ncg_id_=1682b97e315-51c4ce99-0b7f-4994-8781-14746f45fe7f; __ssn=dae48bd1-8575-48ac-9d51-27bd07bacfca; __ssnstarttime=1548221607; userStatus=return_user; automation=false; split=n; bcc=false; bcvariation=SRPBCRR%3Av1%3Adesktop; header_slugs=gs%3DAdair-County_MO%26lo%3DAdair%26st%3Dcounty; ab_srp_viewtype=ab-list-view; criteria=loc%3DAdair+County%2C+MO%26locSlug%3DAdair-County_MO%26lat%3D40.190562%26long%3D-92.600719%26status%3D1%26pg%3D1%26pgsz%3D48%26sprefix%3D%2Frealestateandhomes-search%26city%3DAdair+County%26state_id%3DMO; srchID=be158ecc1301418f8a3b881bc47a8bc5; _ncg_sp_ses.cc72=*; _fbp=fb.1.1548229728818.1374132530; AWSALB=/bTmyIu5nlvbnACPmfjR1nAT2QtPGZjWun45It7FAVGsHuftFBvIWLc+38t9pAsLy2yUqUXMNpha1iMQGBv+ATeWIch7JhWPNybKy8LzVYGMFSQiF6Z8kJfP3hHV3m40228anyBezHl3NwQiHhK4s/nNH5zibgotk1hn86s0opoCavwjXQTIiP5doylcUQ==; _rdc-next_session=dDNod0Nvd1ZDdEZDV0xQV242U2lYdTI0aVZKR1J3dkN2MTkzL055RzVmMGFxS0xML2xFeXhZNHpOMnZadkVUNU5lUDlTU0xuU0d3VTh6ajlJTEN2MGozcHNDc1VUOGhEQUZMb2VSN2dkUHV1UVI1SDhFTm1QR0M2SHRQek1udHVwZjV2cmpvdW5TVkNlcXBxNTVLUTVLcmQxbUJzL0dqcXF3ZzBwZWF5SmVtUXZHL0E5dW4wUDM0V1hWSThHSGd2SmN3TFpPNXY5NkJkNno0OGNPWEFyQnVqUXJaUWRjcE5SUXNyaWMvb2NwTG0rbklXZ0hKeFEyWUJzRnFNclY0WS0tRHMzZDFtcjNEKzBWTDhTWUtwVVRjQT09--7f95f7bded29d4ea1340c765bec95c793a17ace9; _ncg_sp_id.cc72=c8b8f168-bbc0-4797-b97c-384bcd5da00d.1548122553.5.1548231603.1548143865.7e020ece-e650-47b8-a75b-5cc6c9b51159; _4c_=fVLbctowEP2VjJ5j0P3CGyGdJm0JhCSlfWKEJYOLgz2ygZDAv3cF5DJtp36Qd1dnd492zwvazP0SdYjgmjJilJSanaOF39ao84LSKp7reKxCgTpo3jRV3Wm3N5tNK3hbNGVopeVjO9q%2Bbmzj7dLNy0dfJ7W3IZ23u87mIemVq2WznfQH6BylpfNQipiWalHwm2fwuMZgVqF0q7SZNNsqQjZ%2Bela7BVx8LstZ4a8vIZg5nOFMuMQJNU24TnWieaYS7w1jNNNSEg0Z3%2FM6B3aHlIQoQzGn3Oz6vevL%2B7sdBEh0%2BteXO6W5whiyJIM%2FJZJihqmiUjDNtVGGUcYwgLvd%2FrerJI5KUUEN3xFyjF68B8Vu9HVejZ71Isxo820gq9nqx7gSZbHopg%2FL%2FPbn8Mr2x%2BOZ%2B8Kenofj20f3C2%2BhDPC62iWCGwrMZCw8GN4PHu4PpQlV0vB6dzO4%2BRRbAutoxuHNg6%2FnZeEma1us4tC0gXA9Wedgv89hchgE%2BBe29ql9hMWiG3Cn6dqG3DZ5CSpAd6PhRW806qxJx%2Fl60ZRV3FdRNwEu1xEeyk3to9ebB1jzmSIQLUEsaJwvHVyCG3zmQzigIpW8ibQ%2BqOUUBJG9x%2BPy11EVDKyiTEFO4IE0YffdycOBPdHYSC45Zy0YiiKGEK7Q%2Fhw9HQXMAICZpBTG0oBateQ4foAIuTspGWWWWDwVTmdcS0UJMZ5IlWEq0sx64tCpnhAauhktpNgfyR3yCfuzH%2FlHv%2BOc%2FpNE%2Bd9JVfEKf0NTJjEDGuKEJvwNHRd8fBHmYioFyaS2GuvUeuG1YsSxjOM0Swn6UI5xzIR5bR65xGr7%2FW8%3D',
                                            # 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36',
                                            # 'user-agent':'Opera/9.80 (X11; Linux x86_64; U; fr) Presto/2.9.168 Version/11.50',
                                            # 'user-agent': 'Opera/9.80 (X1u) Presto/2.9.168 Version/11.50',
                                            'User-Agent': 'Mozilla/5.0 (Winds NT 6.1; WOW64) ApKit/56 (KHTML, like Gecko) Chrome/27.0.14.93 Sa7.36',
                                            # 'User-Agent': start_user_agent,
                                            # 'referer': 'www.realtor.com',
                                            },
                            使用的user-agent:
                                在这种情况下虽然没有停止:但是出现了301错误:
                                    2019-01-28 14:31:59 [scrapy.spidermiddlewares.httperror] INFO: Ignoring response <301 https://www.realtor.com/realestateandhomes-search/Hills-County_FL>: HTTP status code is not handled or not allowed
                            /realestateandhomes-search/Saint-Francis-County_AR
                            /realestateandhomes-search/Saint-Francois-County_MO
                            Saint-Francois-County_MO
                            /realestateandhomes-search/Saint-Charles-County_MO
                            /realestateandhomes-search/Saint-Francis-County_AR
                            Saint-Lucie-County_FL
                            /realestateandhomes-search/Saint-Johns-County_FL
                            /realestateandhomes-search/Saint-Clair-County_AL
                            /realestateandhomes-search/Hills-County_FL
                            https://www.realtor.com/realestateandhomes-search/Saint-Bernard-County_LA>

                            这里就牵涉出了一个大问题:
                                关于referer + cookie + user-agent的组合问题;


                             等一下依旧用这个爬虫进行测试,看一下问题出在那里,6种组合方式:排除肯定要user-agent的方式,就只有4中方式:
                                1:编码这三种方式:user-agent cookie referer
                                2:user-agent没有的就不用测试了:肯定不行
                                3:100:
                                    结果,能够稳定的跑完3000多个请求

                                4:101:
                                    结果:能够稳定跑

                                5:110:
                                    结果,能够稳定的跑完3000多个请求

                                6:111::
                                    在韩国的ip下竟然能正常运行,奇怪,用的是假的user-agent







                            7:解决办法:加上下载延迟;降低它每分钟的请求次数
                            8:realtor 网站大致有2043219条数据;



关于middleware中的一些问题:(编码问题:):
    1:怎样再重试302请求
    2:怎样在middleware中重试302请求
    3:怎样在middleware中重试请求并携带新的header
    4:怎样才能使我其中的一个处理302 middleware中新设置的user-agent起作用;而不至于更换之后依旧禁止请求
        没起作用的猜想:
            1:没有设置沉睡时间:原因:还是同一个http连接(但是根据http协议应该不是)
            2:设置延迟时间之后依旧没有起作用
            3:可能是假的user-agent导致的错误;


爬虫是一个i0密集型的操作,可以采用多线程的方式进行运行:
    目前用多线程+proxy 代理依然存在的问题:
        1:多线程方面:
            多线程的使用以及多进程的使用,在python中的区别,以及选择哪一个更优,对于这个项目
            多线程启动scrapy会不会有变量上的问题;
        2:之前存在的爬虫方面的问题:如何向爬虫传递参数,在多进程的程序中只能复制粘贴很多个spider,然后进行运行,这样很不科学;
            1:再次尝试能不能给爬虫传递custom_settings的参数(之前测试是只能传递url参数,传递的custom_settings不起作用;
            2:如果上面的不能成功,能不能考虑传递一个meta信息,然后将header中的user-agent改变
            3:上诉两种方法都不成功的情况下:考虑随机的情况,这样就可能让爬虫起始的user-agent不一样;

            4:上诉不成功的情况下就只能将复制粘贴代码了
            5:还可以使用的是随机的user-agent,但是这样很容易被封ip,但是考虑到如果使用代理ip的话,就直接随机效果可能更好,不需要在
                custom_settings中设置default_request_headers 了
        3:关于分布式的解决策略(这个在多进程中可能好使,但是多线程可能有问题,多线程可能会共用变量;)
            1:开启多个进程,使用scrapy-redis,然后将搜索条件全部插入到redis中,
                2:这里有个问题:如果代理ip足够多的情况下,可以开很多的抓取进程;

        4:关于代理ip middleware的问题:
            1:ip的有效性判定
                1:判定策略的把控
                    1:延迟(需不需要在高延迟的情况下判定为无效的)(即timeout的设置)
                    2:400+ 错误以及500+错误的问题是否应该判定为ip无效
                    3:对于300+错误的处理(因为被封网站时候就会被重定向),所以出现这个错误的时候可以换ip
                        但是也可以不换,但是要考虑之前的usero-agent是动态变化的还是固定之后被封了之后再变;
            2:ip变换策略

            3:ip抽取策略

            整个ip代理过程如何过程化;


1:起始现在需要解决的问题还是关于向scrapy传递customsettings的问题;如果不能传那么就可能存在被封ip的情况;
2:关于default_reqeust_headers的问题:
    1:在middleware在处理出现302码出现的问题:(优先级的问题)以及语法问题;
        1:request.headers['User-Agent'] = 'my user agent hahaha',这个设置只对当前的这个url起作用,对整个项目的default_user_agent 没有作用;
        所以最好不要在custom_settings或者settings中设置user-agent;因为设置了这个之后,就会一直存在于整个项目中的middleware中,对于所有的请求都会经过这个中间件,如果想要覆盖掉原来的user-agent就必须要让新的
        中间件的优先级高于scrapy内部的 'scrapy.contrib.downloadermiddleware.defaultheaders.DefaultHeadersMiddleware': 550,
        这个middleware,会在每一次的请求之中都会运行:
        那么在之前的会覆盖掉系统的,所以没有用,
            1:最好将user-agent从default中分离出来
            2:在middleware中的process_request 维护一个user-agent,同时需要一个变量,在在process_response中遇到302 时候将他值为true,传到process_request中;
            3:需要维护一个user-agent 列表,遇到302 之后将该user-agent 保存到一个新的文件中;
            4:随机获取一个user-agent 遇到302 之后在变化;

        遇到的一个问题:中间件中设置的default_headers不会一直有效,所有的request都要经过中间件的处理,也就是说一次性变化的header是只对当前的请求
        有作用的:
            解决办法:(default_request_header中是不能设置user-agent的,只能设置一些通用的设置)
                1:process_request中维护一个固定的index数组然后从中取出一个:但是随之而来的问题就是在开启多进程的时候需要复制很多spider进行运行,代码冗余;
                2:如果采用随机的方式获取,这个方式可以极大的简化代码,但随之而来的是提高了被封的风险(一个ip下是有用户限制的,(这里的服务器应该是将一个user-agent看成一个用户),如果用户过多会导致直接封ip)

                这里暂时只考虑维护一个固定的user-agent;同时加大更换user-agent的sleep时间


                经过测试:得出,开启三个进程的时候爬取速度能达到2万一个小时,使用的是日本2的节点;
                下载测试继续增加进程的状况:
                    1:直接怎加到20个进程,速度达到300kb-400kb每秒的情况;
                    2:9.20开始抓的;
                    3:




# 现如今需要解决scrapy的使用问题:
    1:最需要解决的就是断点续爬(也就是爬虫的停止(停止的时候如何保存爬取状态,)重启的时候从断点处重新开始;
        # 这里可以用之前的程序测一下scrapy自带的停止策略;
        这个很重要,牵涉到最终的部署问题
        1:使用scrapy 自带的任务作业
             # "-s",
             # "JOBDIR=crawls/realtor{}".format(num),
             但是这种方法存在的问题是需要在终端中输入ctrl c 信号才能停止爬虫,这种方式的停止才会保存完整的断点,其他方式的可能存在断点不完整的情况,还有一种是发送一个信号(但是没有理解这里的信号是什么)

        2:使用scrapy-redis来运行:
            但是存在如下疑问:
                1:对于断点有没有记录(需要了解scrapy的过滤是如何实现的),
                2:对于相同的爬虫,爬虫里面yield的请求会不会再返回到redis中保存;

    2:代理ip列表和user-agent存储的优化
        1:user-agent 的存储问题
            1:可以存在一个文本中;然后导入成一个列表,但是没有必要存在一个数据库中
            2:proxy_IP 的处理策略:存在数据库中,需要一个脚本定期爬取,然后检测ip是否有效然后弄一个字段来确定是否有效:
                然后在使用的时候将有效的查询出来存成一个全局的list,然后使用,如果超时或者不好使就从列表中去除;
    3:多线程和多进程开启scrapy程序测试问题:
        1:多进程目前运行正常,
        2:但是多线程不知道怎么样


    4:部署问题:
        1:部署策略:
            1:scrapyd
                1:需要解决如何向爬虫传递参数(这里是user-agent和proxy_ip)
            2:scrapy_redis
                1:但是不知道当所有的爬虫程序都停止之后能不能实现断点续传;(可能需要自己实现)
            3:docker部署(最好是用docker将爬虫容器化)

    5:爬虫中间件问题
    6:最终程序(代码)的优化问题:

















































